# Запуск проекта

Для запуска необходимы Node.js старше 16.x, MongoDB не страше 5.0 и не младше 4.4, OS UBUNTU-20.04. 
Для запуска в Docker, убедитесь, что у вас есть два .env файла:

- .env (или .env.dev для разработки)
- .env.docker (для запуска проекта в docker в dev режиме)

Примеры значений переменных можно увидеть в .env.example.

##Запуск в режиме разработки
__Через NPM__ - это запустит ваш проект в attached режиме. Это значит, что вы будете видеть стандартный вывод (STDOUT) и стандартный вывод ошибок (STDERR) контейнера в вашем терминале в реальном времени.
```
npm run start:dev:docker
```
__Через Docker Compose__
```
docker-compose -f docker-compose-dev.yml up --env-file .env.dev --env-file .env.db -d
```
Это запустит ваш проект в фоновом режиме.

В обоих случаях будут запущены контейнеры с бэкендом и базой данных.

__Локально через NPM__ - позволит вести видеть изменения в реальном времени и работать с локальной БД
```
npm run start:dev
```
##Запуск в режиме production
```
docker-compose -f docker-compose.yml --env-file .env up -d
```
***
## Для того чтобы увидеть документацию Swagger
```
http://127.0.0.1:<Порт на котором запущен сервер>/api/docs
#Пример http://127.0.0.1:3001/api/docs
```
***
## Настройка и использование pre-commit хуков с Husky и Commitizen
__Pre-commit__ хуки помогают автоматизировать процесс проверки и форматирования кода перед коммитом, обеспечивая соблюдение кодового стиля и других стандартов качества.

__Шаг 1: Установка зависимостей.__ Первым шагом является установка всех необходимых зависимостей. Это можно сделать, выполнив следующую команду в корневой директории проекта:
```
npm i
```
__Шаг 2: Установка Commitizen глобально.__ Commitizen - это инструмент, который помогает создавать правильно отформатированные сообщения коммитов. Установите его глобально, используя следующую команду:
```
npm i -g commitizen
```
__Шаг 3: Инициализация Husky.__ Husky - это инструмент для работы с git hooks. Инициализируйте Husky, выполнив следующую команду:
```
npm run prepare
```
__Шаг 4: Совершение коммита с помощью Commitizen.__ Теперь, когда все готово, вы можете сделать коммит, используя Commitizen. Это обеспечит форматирование ваших сообщений коммитов в соответствии с выбранным вами стандартом. Введите следующую команду и следуйте появившимся инструкциям:
```
git cz 
```
Подробное описание после введения команды git cz

__1. Выберите тип изменения, которое вы фиксируете (Select the type of change that you're committing):__
- __feat__ (Feature): Новая функциональность или особенность, добавленная в проект.
- __fix__ (Bug Fix): Исправление ошибки или бага в проекте.
- __docs__ (Documentation): Изменения, касающиеся только документации проекта.
- __style__ (Style): Изменения, которые не влияют на смысл кода (например, пробелы, форматирование, отсутствующие точки с запятой и т.д.).
- __refactor__ (Refactoring): Изменение кода, которое не исправляет ошибку и не добавляет функциональности.
- __perf__ (Performance): Изменение кода, которое улучшает производительность.
- __test__ (Tests): Добавление отсутствующих тестов или корректировка существующих тестов.
- __build__ (Build System): Изменения, которые влияют на систему сборки или внешние зависимости (например, области применения: gulp, broccoli, npm).
- __ci__ (Continuous Integration): Изменения в файлах и скриптах конфигурации CI (например, области применения: Travis, Circle, BrowserStack, SauceLabs).
- __chore__ (Chores): Другие изменения, которые не модифицируют исходные файлы или тестовые файлы.
- __revert__ (Revert): Возврат предыдущего коммита.

__2. Область изменения (Scope of change):__ Это может быть название компонента, файла, модуля или любой другой логической части проекта, которую затрагивают ваши изменения. Это помогает другим разработчикам быстро понять, какая часть кода была изменена в этом коммите. Напрмиер:

- Если вы обновили документацию для конкретного компонента, например, LoginComponent, вы можете ввести LoginComponent в качестве области изменения.
- Если вы обновили README файл, вы можете ввести README в качестве области изменения.
- Пропуск (Skip): Если область изменения не применима или не важна для данного коммита, вы можете пропустить этот шаг, нажав клавишу Enter.

__3. Краткое описание изменений (Short description of the change):__ Это сообщение поможет другим разработчикам понять, что было сделано в этом конкретном коммите, не заглядывая в код. Это сообщение должно быть формулировано в императивном наклонении и должно ясно и точно описывать суть выполненных вами изменений.

- Императивное наклонение (Imperative tense): Сообщение коммита должно быть написано в императивном наклонении, что является стандартной практикой для сообщений коммитов. Это значит, что сообщение должно начинаться с глагола в повелительном наклонении, например, "Добавить", "Изменить", "Исправить" и так далее.
- Commitizen устанавливает ограничение в 82 символа для этого описания, чтобы сообщения коммитов были короткими и лаконичными.

__4. Предоставьте более подробное описание изменения (Provide a longer description of the change):__ Этот шаг в процессе создания коммита предлагает вам предоставить более подробное описание изменений. Это поле является необязательным, и вы можете пропустить его, нажав Enter, если считаете, что краткое описание достаточно информативно. Это может включать в себя технические детали, ссылки на связанные задачи или запросы на вытягивание, или другую информацию, которая может быть полезной для других разработчиков или для будущего вас

__5. Вносят ли ваши изменения какие-либо обратно несовместимые изменения в проект (Are there any breaking changes?):__ Этот вопрос в процессе создания коммита спрашивает, вносят ли ваши изменения какие-либо обратно несовместимые изменения в проект. Обратно несовместимые изменения - это изменения, которые могут привести к сбоям или ошибкам в существующем коде, если другие разработчики или системы используют старую версию вашего кода. Примеры включают удаление функций, изменение сигнатур функций или изменение формата возвращаемых данных.

- Если ваши изменения включают обратно несовместимые изменения, введите y (да).
- Если ваши изменения не включают обратно несовместимые изменения, введите N (нет).

__6.Влияют ли ваши изменения на какие-либо открытые вопросы или задачи в вашем проекте (Does this change affect any open issues?):__ Этот вопрос связан с тем, влияют ли ваши изменения на какие-либо открытые вопросы или задачи в вашем проекте. Он может быть связан с системой отслеживания задач, такой как Jira или GitHub Issues, которая используется в вашем проекте для отслеживания задач и проблем.

- Если ваш коммит адресует или влияет на какие-либо открытые вопросы, введите y (да).
- Если ваш коммит не влияет на какие-либо открытые вопросы, введите N (нет).

__7.После того как сообщение коммита было создано и сохранено, Husky начинает свою работу.__ 

- Husky запускает commitlint, который проверяет ваше сообщение коммита на соответствие определенным правилам. Если сообщение коммита не соответствует этим правилам, commitlint вернет ошибку, и коммит будет отклонен.
```
commitlint.config.js # Правила для коммитов
```
- Затем Husky запускает lint-staged, который запускает линтеры на измененных файлах. lint-staged может автоматически исправлять ошибки или предлагать исправления, в зависимости от вашей конфигурации.
- Если все хуки успешно прошли, и нет ошибок, то ваш коммит будет завершен, и изменения будут зарегистрированы в вашем репозитории git.

***
## MongoDb работает с транзакциями, поэтому необходимо установить 
__Шаг 1:__ Найдите файл конфигурации MongoDB на вашем устройстве. Обычно он называется __mongod.conf.__

__Шаг 2:__ Добавьте следующие строки в ваш файл конфигурации:
```
replication:
  replSetName: "rs0"  # имя набора реплик
```
__Шаг 3:__ Сохраните и закройте файл конфигурации.

__Шаг 4:__ Перезапустите MongoDB с обновленной конфигурацией. В зависимости от вашей операционной системы выполните одну из следующих команд в терминале:
- Windows:
```
mongod --config "путь\до\вашего\mongod.conf" --install
```
- MacOS:
```
brew services start mongodb-community --config=/путь/до/вашего/mongod.conf
```
__Шаг 5:__ Откройте MongoDB shell, выполнив следующую команду в терминале:
```
mongo
```
__Шаг 6:__ После успешного подключения инициализируйте репликацию, введя следующую команду в MongoDB shell:
```
rs.initiate()
```
__Шаг 7:__ Проверьте статус репликации, введя следующую команду в MongoDB shell:
```
rs.status()
```
__Шаг 8:__ В файле с переменными среды (env) вашего проекта добавьте следующую строку:
```
DB_REPLICATION_SET=name replication set
```
## Обработка ошибок и логгирование

все обьявленные через catch ошибки перехватываются глобально через кастомный фильтр исключений utils/globalFilterHTTP.expection    (https://docs.nestjs.com/exception-filters#exception-filters-1)
неучтенные ошибки перехватываются в main.ts через process

Логгирование с помощью пакета nest-winston (https://www.npmjs.com/package/nest-winston) добавлена фабрика логгер в папке utils.

Для добавления по необходимости логгера в разные места проекта: через класс из пакета @nestjs/common -  Logger.error('ошибки'),

## Использование AppClusterService для Кластеризации

### Описание

`AppClusterService` — это класс, предназначенный для оптимизации использования ресурсов многоядерных систем в Node.js приложениях с помощью кластеризации. Он позволяет легко создавать несколько экземпляров Node.js (кластеров), работающих параллельно на разных ядрах процессора, что повышает производительность и надёжность приложения.

### Как это работает

Класс использует модуль `cluster` Node.js для создания "главного" процесса (primary), который затем порождает несколько "рабочих" процессов (workers) — кластеров. Каждый кластер выполняет одинаковый код и работает на отдельном ядре процессора. Это позволяет более эффективно распределять нагрузку и повышает отказоустойчивость системы, так как при сбое одного кластера, остальные продолжают работать, и проблемный кластер может быть перезапущен.

### Пример использования

Для использования `AppClusterService`, необходимо вызвать его метод `clusterize`, передав в него функцию, которую вы хотите выполнить в каждом кластере, и, опционально, количество ядер, которое вы хотите использовать.

```
import { AppClusterService } from './path/to/AppClusterService';

AppClusterService.clusterize(() => {
  // Ваш код, который будет исполняться в каждом кластере
}, numCores);
```